<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Amal Thomas" />


<title>SBF vignette</title>

<script src="data:application/javascript;base64,Ly8gUGFuZG9jIDIuOSBhZGRzIGF0dHJpYnV0ZXMgb24gYm90aCBoZWFkZXIgYW5kIGRpdi4gV2UgcmVtb3ZlIHRoZSBmb3JtZXIgKHRvCi8vIGJlIGNvbXBhdGlibGUgd2l0aCB0aGUgYmVoYXZpb3Igb2YgUGFuZG9jIDwgMi44KS4KZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uKGUpIHsKICB2YXIgaHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCJkaXYuc2VjdGlvbltjbGFzcyo9J2xldmVsJ10gPiA6Zmlyc3QtY2hpbGQiKTsKICB2YXIgaSwgaCwgYTsKICBmb3IgKGkgPSAwOyBpIDwgaHMubGVuZ3RoOyBpKyspIHsKICAgIGggPSBoc1tpXTsKICAgIGlmICghL15oWzEtNl0kL2kudGVzdChoLnRhZ05hbWUpKSBjb250aW51ZTsgIC8vIGl0IHNob3VsZCBiZSBhIGhlYWRlciBoMS1oNgogICAgYSA9IGguYXR0cmlidXRlczsKICAgIHdoaWxlIChhLmxlbmd0aCA+IDApIGgucmVtb3ZlQXR0cmlidXRlKGFbMF0ubmFtZSk7CiAgfQp9KTsK"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">
/* for pandoc --citeproc since 2.11 */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="data:text/css,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20800px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%2020px%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%200%3B%0Apadding%3A%204px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%3Anot%28%5Bclass%5D%29%20%7B%0Amargin%3A%20auto%3B%0Amin%2Dwidth%3A%2040%25%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%5Bsummary%3D%22R%20argblock%22%5D%20%7B%0Awidth%3A%20100%25%3B%0Aborder%3A%20none%3B%0A%7D%0Atable%3Anot%28%5Bclass%5D%29%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%3Anot%28%5Bclass%5D%29%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%3Anot%28%5Bclass%5D%29%2C%20table%3Anot%28%5Bclass%5D%29%20th%2C%20table%3Anot%28%5Bclass%5D%29%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%3Anot%28%5Bclass%5D%29%20tr%2Eodd%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%2013px%3B%0Apadding%2Dbottom%3A%201px%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f5f5f5%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0A%7D%0Apre%20%7B%0Aoverflow%2Dx%3A%20auto%3B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200%2010px%200%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20white%3B%0Aborder%3A%20%23f5f5f5%201px%20solid%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20code%20%7B%0Acolor%3A%20%23444%3B%0Abackground%2Dcolor%3A%20white%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20monospace%3B%0Afont%2Dsize%3A%2090%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%204px%3B%0Acolor%3A%20%23d14%3B%0Aborder%3A%201px%20solid%20%23e1e1e8%3B%0Awhite%2Dspace%3A%20inherit%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Atable%20%3E%20caption%2C%20div%2Efigure%20p%2Ecaption%20%7B%0Afont%2Dstyle%3A%20italic%3B%0A%7D%0Atable%20%3E%20caption%20span%2C%20div%2Efigure%20p%2Ecaption%20span%20%7B%0Afont%2Dstyle%3A%20normal%3B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%200%2010px%3B%0A%7D%0Atable%3Anot%28%5Bclass%5D%29%20%7B%0Amargin%3A%20auto%20auto%2010px%20auto%3B%0A%7D%0Aimg%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0Amax%2Dwidth%3A%20100%25%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f5f5f5%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f5f5f5%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f5f5f5%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Adiv%2Er%2Dhelp%2Dpage%20%7B%0Abackground%2Dcolor%3A%20%23f9f9f9%3B%0Aborder%2Dbottom%3A%20%23ddd%201px%20solid%3B%0Amargin%2Dbottom%3A%2010px%3B%0Apadding%3A%2010px%3B%0A%7D%0Adiv%2Er%2Dhelp%2Dpage%3Ahover%20%7B%0Abackground%2Dcolor%3A%20%23f4f4f4%3B%0A%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" type="text/css" />




</head>

<body>




<h1 class="title toc-ignore">SBF vignette</h1>
<h4 class="author">Amal Thomas</h4>


<div id="TOC">
<ul>
<li><a href="#background">Background</a></li>
<li><a href="#shared-basis-factorization">Shared basis factorization</a>
<ul>
<li><a href="#estimating-the-shared-right-basis-matrix">Estimating the shared right basis matrix</a></li>
</ul></li>
<li><a href="#approximate-shared-basis-factorization">Approximate shared basis factorization</a></li>
<li><a href="#usage-cases">Usage cases</a>
<ul>
<li><a href="#sbf-examples">SBF examples</a>
<ul>
<li><a href="#adding-new-dataset">Adding new dataset</a></li>
</ul></li>
<li><a href="#a-sbf-examples">A-SBF examples</a></li>
</ul></li>
<li><a href="#reduce-a-sbf-factorization-error">Reduce A-SBF factorization error</a>
<ul>
<li><a href="#proposition-i">Proposition I</a></li>
<li><a href="#proposition-ii">Proposition II</a></li>
<li><a href="#proposition-iii">Proposition III</a></li>
<li><a href="#iterative-update">Iterative update</a></li>
<li><a href="#examples">Examples</a>
<ul>
<li><a href="#optimizing-a-sbf-error">Optimizing A-SBF error</a></li>
<li><a href="#using-different-initial-values">Using different initial values</a></li>
<li><a href="#estimating-svd">Estimating SVD</a></li>
</ul></li>
</ul></li>
<li><a href="#cross-species-gene-expression-analysis-using-a-sbf">Cross-species gene expression analysis using A-SBF</a>
<ul>
<li><a href="#usage-examples">Usage examples</a></li>
</ul></li>
<li><a href="#references">References</a></li>
</ul>
</div>

<style>
body {
text-align: justify}
</style>
<div id="background" class="section level1">
<h1>Background</h1>
<p>Joint matrix factorization facilitates the comparison of expression profiles from different species without using gene mapping. Transforming gene expression profiles into reduced eigengene space using singular value decomposition (SVD) has been shown to capture meaningful biological information <span class="citation">(Alter, Brown, and Botstein 2000)</span>. <span class="citation">Tamayo et al. (2007)</span> used a non-negative matrix factorization approach to learn a low-dimensional approximation of the microarray expression datasets and used the reduced space for comparisons. Matrix factorization-based methods are commonly used for gene expression analysis <span class="citation">(Alter, Brown, and Botstein 2000; Tamayo et al. 2007)</span>. An orthology independent matrix factorization framework based on generalized singular value decomposition [GSVD; <span class="citation">Van Loan (1976)</span>] was used by <span class="citation">Alter, Brown, and Botstein (2003)</span> to compare gene-expression profiles from two species. This framework was later extended to develop higher-order generalized singular value decomposition (HO GSVD) to analyze data from more than two species <span class="citation">(Ponnapalli et al. 2011)</span>.</p>
<p>This study developed a joint diagonalization approach called approximate shared basis factorization (A-SBF) for cross-species expression comparisons. This approach extends the exact factorization approach we developed called shared basis factorization (SBF). We discuss the details of the two methods in the following sections.</p>
</div>
<div id="shared-basis-factorization" class="section level1">
<h1>Shared basis factorization</h1>
<p>Consider a set of real matrices <span class="math inline">\(D_i \in \mathbb{R}^{m_i \times k}\)</span> (<span class="math inline">\(i={1,\ldots ,N}\)</span>) with full column rank. We define shared basis factorization (SBF) as</p>
<p><span class="math display">\[\begin{align*}
  D_1 &amp;= U_1\Delta_1V^T, \\
  D_2 &amp;= U_2\Delta_2V^T, \\
      &amp; \vdots \\
  D_N &amp;= U_N\Delta_NV^T.
\end{align*}\]</span></p>
<p>Here each <span class="math inline">\(U_i \in \mathbb{R}^{m_i \times k}\)</span> is a dataset-specific left basis matrix, each <span class="math inline">\(\Delta_i \in \mathbb{R}^{k \times k}\)</span> is a diagonal matrix with positive values <span class="math inline">\(\delta_{ik}\)</span>, and <span class="math inline">\(V\)</span> is a square invertible matrix.</p>
<div id="estimating-the-shared-right-basis-matrix" class="section level2">
<h2>Estimating the shared right basis matrix</h2>
<p>Let <span class="math inline">\(M\)</span> be the scaled sum of the <span class="math inline">\(D_i^T D_i\)</span>. We define <span class="math inline">\(M\)</span> is defined as <span class="math display">\[
 M = \frac{\sum_{i=1}^{N} D_i^T D_i/w_i}{\alpha}.
\]</span></p>
<p>The scaling factor <span class="math inline">\(w_i\)</span> is the total variance explained by the column vectors of <span class="math inline">\(D_i\)</span>, and <span class="math inline">\(\alpha\)</span> is the inverse sum of the total variance of <span class="math inline">\(D_i\)</span>, for <span class="math inline">\(i = 1 \cdots N\)</span>. The weights <span class="math inline">\(w_i\)</span> and <span class="math inline">\(\alpha\)</span> are defined as</p>
<p><span class="math display">\[\begin{align*}
    w_i &amp;= \sum_{j=1}^{k} \sigma_{jj}^{2\mbox{ }(i)} \mbox{ and}\\
    \alpha &amp;= \sum_{i=1}^{N} \frac{1}{\sum_{j=1}^{k} \sigma_{jj}^{2\mbox{ }(i)}}.
\end{align*}\]</span></p>
<p>Here <span class="math inline">\(\sum_{j=1}^{k} \sigma_{jj}^{2\mbox{ }(i)} = \mathrm{tr}(D_i^T D_i) = \mathrm{tr}(A_i)\)</span>. Using the <span class="math inline">\(w_i\)</span> and <span class="math inline">\(\alpha\)</span>, individual <span class="math inline">\(D_i^T D_i\)</span> are standardized. If all the variances are equal, <span class="math inline">\(M\)</span> becomes the arithmetic mean of the sum of <span class="math inline">\(D_i^T D_i\)</span>. The shared right basis matrix <span class="math inline">\(V\)</span> is then determined from the eigenvalue decomposition of <span class="math inline">\(M\)</span>, where <span class="math inline">\(M=V \Theta V^T\)</span>. The shared right basis matrix <span class="math inline">\(V\)</span> is an orthogonal matrix as <span class="math inline">\(M\)</span> is symmetric. Given <span class="math inline">\(V\)</span>, we compute <span class="math inline">\(U_i\)</span> and <span class="math inline">\(\Delta_i\)</span> by solving the linear system <span class="math inline">\(D_i V = U_i \Delta_i = L_i\)</span>. By normalizing the columns of <span class="math inline">\(L_i\)</span>, we have <span class="math inline">\(\delta_{ik} = \|l_{ik}\|\)</span> and <span class="math inline">\(\Delta_i = \mbox{diag}(\delta_{i1},\ldots,\delta_{ik})\)</span>.</p>
</div>
</div>
<div id="approximate-shared-basis-factorization" class="section level1">
<h1>Approximate shared basis factorization</h1>
<p>Consider a set of matrices <span class="math inline">\(D_i \in \mathbb{R}^{m_i \times k}\)</span> (<span class="math inline">\(i= 1,\ldots,N\)</span>), each with full column rank. We define approximate shared basis factorization (A-SBF) as</p>
<p><span class="math display">\[\begin{align*}
  D_1 &amp;= U_1\Delta_1V^T + \epsilon_1, \\
  D_2 &amp;= U_2\Delta_2V^T + \epsilon_2, \\
      &amp; \vdots \\
  D_N &amp;= U_N\Delta_NV^T + \epsilon_N.
\end{align*}\]</span></p>
<p>Each <span class="math inline">\(U_i \in \mathbb{R}^{m_i \times k}\)</span> is a species-specific left basis matrix with <strong>orthonormal</strong> columns (eigengenes), <span class="math inline">\(\Delta_i \in \mathbb{R}^{k \times k}\)</span> is a diagonal matrix with positive values <span class="math inline">\(\Delta_{ik}\)</span> and <span class="math inline">\(V\)</span> is a non singular square matrix. The right basis matrix <span class="math inline">\(V\)</span> is identical in all the <span class="math inline">\(N\)</span> matrix factorizations and defines the common space shared by all species. We estimate the factorization such that the estimated <span class="math inline">\(V\)</span> is closest to that in the exact decomposition and by minimizing the total decomposition error <span class="math inline">\(\sum^{N}_{i=1}\epsilon_i = {\sum^{N}_{i=1}\|D_i - U_i\Delta_iV^T\|^2}_F\)</span>.</p>
</div>
<div id="usage-cases" class="section level1">
<h1>Usage cases</h1>
<div id="sbf-examples" class="section level2">
<h2>SBF examples</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># load SBF package</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(SBF)</span></code></pre></div>
<p>Let us create some random matrices using the <code>createRandomMatrices</code> function from the SBF package. We will create four matrices, each with three columns with rows varying from 4 to 6.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1231</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>mymat <span class="ot">&lt;-</span> <span class="fu">createRandomMatrices</span>(<span class="at">n =</span> <span class="dv">4</span>, <span class="at">ncols =</span> <span class="dv">3</span>, <span class="at">nrows =</span> <span class="dv">4</span><span class="sc">:</span><span class="dv">6</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="fu">sapply</span>(mymat, dim)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      mat1 mat2 mat3 mat4</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]    5    6    4    5</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,]    3    3    3    3</span></span></code></pre></div>
<p>Rank of each of this matrices</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sapply</span>(mymat, <span class="cf">function</span>(x) {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">qr</span>(x)<span class="sc">$</span>rank</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; mat1 mat2 mat3 mat4 </span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    3    3    3    3</span></span></code></pre></div>
<p>Let us compute SBF using different approaches.</p>
<ul>
<li>Estimate <span class="math inline">\(V\)</span> using sum of <span class="math inline">\(D_i^T D_i / N\)</span></li>
<li>Estimate <span class="math inline">\(V\)</span> using sum of <span class="math inline">\(D_i^T D_i / N\)</span> with inverse variance weighting</li>
<li>Estimate <span class="math inline">\(V\)</span> using inter-sample correlation</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>sbf <span class="ot">&lt;-</span> <span class="fu">SBF</span>(<span class="at">matrix_list =</span> mymat)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>sbf_inv <span class="ot">&lt;-</span> <span class="fu">SBF</span>(<span class="at">matrix_list =</span> mymat, <span class="at">weighted =</span> <span class="cn">TRUE</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>sbf_cor <span class="ot">&lt;-</span> <span class="fu">SBF</span>(<span class="at">matrix_list =</span> mymat, <span class="at">transform_matrix =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<p>When <span class="math inline">\(D_i\)</span>’s are transformed to compute inter-sample correlation, we do not need to scale it using inverse-variance weighting anymore. We recommend using inverse variance weights, giving a more robust estimate of <span class="math inline">\(V\)</span> when noisy datasets are present. We estimate <span class="math inline">\(V\)</span> using inter-sample correlation when dealing with gene expression data sets.</p>
<p><code>?SBF</code> help function shows all arguments for the SBF function. Let us inspect the output of the <code>SBF</code> call.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(sbf)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;v&quot;      &quot;lambda&quot; &quot;u&quot;      &quot;delta&quot;  &quot;m&quot;</span></span></code></pre></div>
<p><code>sbf$u</code>, <code>sbf$v</code>, and <code>sbf$delta</code> correspond to the estimated left basis matrix, shared right basis matrix, and diagonal matrices.</p>
<p>The estimated <span class="math inline">\(V \in R^{k \times k}\)</span> has a dimension of <span class="math inline">\(k \times k\)</span>, where <span class="math inline">\(k\)</span> is the number of columns in <span class="math inline">\(D_i\)</span>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>sbf<span class="sc">$</span>v</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;           [,1]       [,2]       [,3]</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,] 0.4793022  0.8669998  0.1363110</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,] 0.7027353 -0.2860780 -0.6514004</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [3,] 0.5257684 -0.4080082  0.7463892</span></span></code></pre></div>
<p>The delta values for each matrix for the three cases are shown below.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>printDelta <span class="ot">&lt;-</span> <span class="cf">function</span>(l) {</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (eachmat <span class="cf">in</span> <span class="fu">names</span>(l<span class="sc">$</span>delta)) {</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">cat</span>(eachmat, <span class="st">&quot;:&quot;</span>, l<span class="sc">$</span>delta[[eachmat]], <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&quot;sbf</span><span class="sc">\n</span><span class="st">&quot;</span>);<span class="fu">printDelta</span>(sbf)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; sbf</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; mat1 : 205.4915 29.6746 71.43295 </span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; mat2 : 206.5816 71.72548 55.682 </span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; mat3 : 189.9136 52.6758 42.36825 </span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; mat4 : 192.6911 80.22868 58.57913</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&quot;sbf_inv</span><span class="sc">\n</span><span class="st">&quot;</span>);<span class="fu">printDelta</span>(sbf_inv)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; sbf_inv</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; mat1 : 205.5109 22.4888 73.95623 </span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; mat2 : 206.5963 77.00352 48.05638 </span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; mat3 : 189.8719 58.60394 33.92988 </span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; mat4 : 192.6942 72.41955 67.98802</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&quot;sbf_cor</span><span class="sc">\n</span><span class="st">&quot;</span>);<span class="fu">printDelta</span>(sbf_cor)</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; sbf_cor</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; mat1 : 200.4197 44.25134 77.99852 </span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; mat2 : 199.8621 80.34494 67.23723 </span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; mat3 : 176.1738 76.95449 60.64485 </span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; mat4 : 185.4579 67.51833 89.69184</span></span></code></pre></div>
<p>The <span class="math inline">\(V \in R^{k \times k}\)</span> estimated in SBF is orthogonal. So <span class="math inline">\(V^T V = V V^T = I\)</span>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">zapsmall</span>(<span class="fu">t</span>(sbf<span class="sc">$</span>v) <span class="sc">%*%</span> sbf<span class="sc">$</span>v)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1] [,2] [,3]</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]    1    0    0</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,]    0    1    0</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [3,]    0    0    1</span></span></code></pre></div>
<p>The estimated <span class="math inline">\(V\)</span> is an invertible matrix.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">qr</span>(sbf<span class="sc">$</span>v)<span class="sc">$</span>rank</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 3</span></span></code></pre></div>
<p>The <span class="math inline">\(U_i\)</span> matrices estimated in the SBF do not have orthonormal columns. Let us explore that.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sapply</span>(sbf<span class="sc">$</span>u, dim)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      mat1 mat2 mat3 mat4</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]    5    6    4    5</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,]    3    3    3    3</span></span></code></pre></div>
<p>Let us take the first matrix <span class="math inline">\(U_i \in R^{m_i \times k}\)</span> to check this. For this matrix, <span class="math inline">\(U_i^T U_i\)</span> will be <span class="math inline">\(k \times k\)</span> matrix where <span class="math inline">\(k = 3\)</span>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">t</span>(sbf<span class="sc">$</span>u[[<span class="fu">names</span>(sbf<span class="sc">$</span>u)[<span class="dv">1</span>]]]) <span class="sc">%*%</span> sbf<span class="sc">$</span>u[[<span class="fu">names</span>(sbf<span class="sc">$</span>u)[<span class="dv">1</span>]]]</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;             [,1]        [,2]       [,3]</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]  1.00000000 -0.07071457  0.1405487</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,] -0.07071457  1.00000000 -0.6201468</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [3,]  0.14054867 -0.62014676  1.0000000</span></span></code></pre></div>
<p>The estimated <span class="math inline">\(M\)</span> matrix is stored <code>sbf$m</code> and <code>sbf$lambda</code> gives the eigenvalues in the eigenvalue decomposition (<span class="math inline">\(M=V \Theta V^T\)</span>).</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>sbf<span class="sc">$</span>lambda</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 39524.940  3809.127  3357.434</span></span></code></pre></div>
<p>SBF is an exact factorization. Let compute the factorization error for the three cases using <code>calcDecompError</code> function.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">calcDecompError</span>(mymat, sbf<span class="sc">$</span>u, sbf<span class="sc">$</span>delta, sbf<span class="sc">$</span>v)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 1.851693e-26</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="fu">calcDecompError</span>(mymat, sbf_inv<span class="sc">$</span>u, sbf_inv<span class="sc">$</span>delta, sbf_inv<span class="sc">$</span>v)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 1.894292e-26</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="fu">calcDecompError</span>(mymat, sbf_cor<span class="sc">$</span>u, sbf_cor<span class="sc">$</span>delta, sbf_cor<span class="sc">$</span>v)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 2.835482e-26</span></span></code></pre></div>
<p>The errors are close to zero in all three cases.</p>
<div id="adding-new-dataset" class="section level3">
<h3>Adding new dataset</h3>
<p>The total column variance of matrix 1-4 in <code>mymat</code> is approximately in the same range.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sapply</span>(mymat, <span class="cf">function</span>(x) <span class="fu">sum</span>(<span class="fu">diag</span>(<span class="fu">cov</span>(x))))</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;    mat1    mat2    mat3    mat4 </span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 2076.80 2273.50 2375.25 2860.40</span></span></code></pre></div>
<p>Now, let us create two new matrix lists containing the <code>mymat</code>. We will add a dataset with a similar variance to the first list and a high variance to the second.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>mat5 <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">130</span>, <span class="dv">183</span>, <span class="dv">62</span>, <span class="dv">97</span>, <span class="dv">147</span>, <span class="dv">94</span>, <span class="dv">102</span>, <span class="dv">192</span>, <span class="dv">19</span>), <span class="at">byrow =</span> T,</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>                    <span class="at">nrow =</span> <span class="dv">3</span>, <span class="at">ncol =</span> <span class="dv">3</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>mat5_highvar <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">406</span>, <span class="dv">319</span>, <span class="dv">388</span>, <span class="dv">292</span>, <span class="dv">473</span>, <span class="dv">287</span>, <span class="dv">390</span>, <span class="dv">533</span>, <span class="dv">452</span>),</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>                       <span class="at">byrow =</span> T, <span class="at">nrow =</span> <span class="dv">3</span>, <span class="at">ncol =</span> <span class="dv">3</span>)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>mymat_new <span class="ot">&lt;-</span> mymat</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>mymat_new[[<span class="st">&quot;mat5&quot;</span>]] <span class="ot">&lt;-</span> mat5</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="fu">sapply</span>(mymat_new, <span class="cf">function</span>(x) <span class="fu">sum</span>(<span class="fu">diag</span>(<span class="fu">cov</span>(x))))</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;     mat1     mat2     mat3     mat4     mat5 </span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; 2076.800 2273.500 2375.250 2860.400 2299.667</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>mymat_new_noisy <span class="ot">&lt;-</span> mymat</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>mymat_new_noisy[[<span class="st">&quot;mat5&quot;</span>]] <span class="ot">&lt;-</span> mat5_highvar</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="fu">sapply</span>(mymat_new_noisy, <span class="cf">function</span>(x) <span class="fu">sum</span>(<span class="fu">diag</span>(<span class="fu">cov</span>(x))))</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;     mat1     mat2     mat3     mat4     mat5 </span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  2076.80  2273.50  2375.25  2860.40 22915.00</span></span></code></pre></div>
<p>Let us compute SBF with the new datasets.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>sbf_new <span class="ot">&lt;-</span> <span class="fu">SBF</span>(<span class="at">matrix_list =</span> mymat_new)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>sbf_inv_new <span class="ot">&lt;-</span> <span class="fu">SBF</span>(<span class="at">matrix_list =</span> mymat_new, <span class="at">weighted =</span> <span class="cn">TRUE</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>sbf_new_noisy <span class="ot">&lt;-</span> <span class="fu">SBF</span>(<span class="at">matrix_list =</span> mymat_new_noisy)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>sbf_inv_new_noisy <span class="ot">&lt;-</span> <span class="fu">SBF</span>(<span class="at">matrix_list =</span> mymat_new_noisy, <span class="at">weighted =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<p>Let us take the newly estimated values <span class="math inline">\(U_i\)</span>, <span class="math inline">\(\Delta_i\)</span>, and <span class="math inline">\(V\)</span> for the four initial matrices in <code>mymat</code>. We will then compare the decomposition error for the two cases with and without inverse variance weighting.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>e1 <span class="ot">&lt;-</span> <span class="fu">calcDecompError</span>(mymat, sbf_new<span class="sc">$</span>u[<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>], sbf_new<span class="sc">$</span>delta[<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>], sbf_new<span class="sc">$</span>v)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>e2 <span class="ot">&lt;-</span> <span class="fu">calcDecompError</span>(mymat, sbf_new_noisy<span class="sc">$</span>u[<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>], sbf_new_noisy<span class="sc">$</span>delta[<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>],</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>                      sbf_new_noisy<span class="sc">$</span>v)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>e2 <span class="sc">/</span> e1</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 3.887268</span></span></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>e3 <span class="ot">&lt;-</span> <span class="fu">calcDecompError</span>(mymat, sbf_inv_new<span class="sc">$</span>u[<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>], sbf_inv_new<span class="sc">$</span>delta[<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>],</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>                      sbf_inv_new<span class="sc">$</span>v)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>e4 <span class="ot">&lt;-</span> <span class="fu">calcDecompError</span>(mymat, sbf_inv_new_noisy<span class="sc">$</span>u[<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>],</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>                      sbf_inv_new_noisy<span class="sc">$</span>delta[<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>], sbf_inv_new_noisy<span class="sc">$</span>v)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>e4 <span class="sc">/</span> e3</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 1.657059</span></span></code></pre></div>
<p>With inverse variance weighting, the deviation is smaller.</p>
</div>
</div>
<div id="a-sbf-examples" class="section level2">
<h2>A-SBF examples</h2>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1231</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>mymat <span class="ot">&lt;-</span> <span class="fu">createRandomMatrices</span>(<span class="at">n =</span> <span class="dv">4</span>, <span class="at">ncols =</span> <span class="dv">3</span>, <span class="at">nrows =</span> <span class="dv">4</span><span class="sc">:</span><span class="dv">6</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="fu">sapply</span>(mymat, dim)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      mat1 mat2 mat3 mat4</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]    5    6    4    5</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,]    3    3    3    3</span></span></code></pre></div>
<p>Now let us compute Approximate-SBF for the same datasets.</p>
<ul>
<li>A-SBF</li>
<li>A-SBF with inverse variance weighting</li>
<li>A-SBF with inter-sample correlation</li>
</ul>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>asbf <span class="ot">&lt;-</span> <span class="fu">SBF</span>(<span class="at">matrix_list =</span> mymat, <span class="at">approximate =</span> <span class="cn">TRUE</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>asbf_inv <span class="ot">&lt;-</span> <span class="fu">SBF</span>(<span class="at">matrix_list =</span> mymat, <span class="at">weighted =</span> <span class="cn">TRUE</span>, <span class="at">approximate =</span> <span class="cn">TRUE</span>)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>asbf_cor <span class="ot">&lt;-</span> <span class="fu">SBF</span>(<span class="at">matrix_list =</span> mymat, <span class="at">approximate =</span> <span class="cn">TRUE</span>, <span class="at">transform_matrix =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(asbf)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;v&quot;       &quot;lambda&quot;  &quot;u&quot;       &quot;u_ortho&quot; &quot;delta&quot;   &quot;m&quot;       &quot;error&quot;</span></span></code></pre></div>
<p>A-SBF is not an exact factorization. A-SBF output has two additional values. <code>asbf$u_ortho</code> is the left basis matrix with orthonormal columns and <code>asbf$error</code> gives the decomposition error.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>asbf<span class="sc">$</span>error</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 2329.73</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>asbf_inv<span class="sc">$</span>error</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 1651.901</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>asbf_cor<span class="sc">$</span>error</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 14045.99</span></span></code></pre></div>
<p>The same error can also be computed using the <code>calcDecompError</code> function.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">calcDecompError</span>(mymat, asbf<span class="sc">$</span>u_ortho, asbf<span class="sc">$</span>delta, asbf<span class="sc">$</span>v)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 2329.73</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="fu">calcDecompError</span>(mymat, asbf_inv<span class="sc">$</span>u_ortho, asbf_inv<span class="sc">$</span>delta, asbf_inv<span class="sc">$</span>v)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 1651.901</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="fu">calcDecompError</span>(mymat, asbf_cor<span class="sc">$</span>u_ortho, asbf_cor<span class="sc">$</span>delta, asbf_cor<span class="sc">$</span>v)</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 14045.99</span></span></code></pre></div>
<p>In A-SBF factorization, <span class="math inline">\(U_i\)</span> has orthonormal columns, and <span class="math inline">\(V\)</span> is orthogonal.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">zapsmall</span>(<span class="fu">t</span>(asbf<span class="sc">$</span>u_ortho[[<span class="fu">names</span>(asbf<span class="sc">$</span>u_ortho)[<span class="dv">1</span>]]]) <span class="sc">%*%</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>           asbf<span class="sc">$</span>u_ortho[[<span class="fu">names</span>(asbf<span class="sc">$</span>u_ortho)[<span class="dv">1</span>]]])</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1] [,2] [,3]</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]    1    0    0</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,]    0    1    0</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [3,]    0    0    1</span></span></code></pre></div>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">zapsmall</span>(<span class="fu">t</span>(asbf<span class="sc">$</span>v) <span class="sc">%*%</span> asbf<span class="sc">$</span>v)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1] [,2] [,3]</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]    1    0    0</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,]    0    1    0</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [3,]    0    0    1</span></span></code></pre></div>
</div>
</div>
<div id="reduce-a-sbf-factorization-error" class="section level1">
<h1>Reduce A-SBF factorization error</h1>
<p>We will use the following propositions to develop an iterative approach to minimize the factorization error.</p>
<div id="proposition-i" class="section level2">
<h2>Proposition I</h2>
<p>Let <span class="math inline">\(A \in \mathbb{R}^{m \times n}\)</span> with rank <span class="math inline">\(n\)</span> and SVD of <span class="math inline">\(A Q^T = X \Sigma Y^T\)</span>. Among all matrices <span class="math inline">\(B \in \mathbb{R}^{m \times n}\)</span> with orthonormal columns, the Forbenius norm <span class="math inline">\(\|A - B Q\|^2_F\)</span> is minimized when <span class="math inline">\(B = X Y^T\)</span>.</p>
<p><span class="math display">\[
\begin{aligned}
  \min \|A - B Q\|^2_F &amp;= \mathrm{tr}\left( A - BQ \right)^T (A - BQ) \\
  &amp;= \mathrm{tr}(A^T A) + \mathrm{tr}(Q^T Q) - 2 \mathrm{tr}(A Q^T B^T).  
\end{aligned}
\]</span></p>
<p>This is equivalent to maximizing <span class="math inline">\(\mathrm{tr}(A Q^T B^T)\)</span>. Let SVD of <span class="math inline">\(AQ^T = X \Sigma Y^T\)</span>, where <span class="math inline">\(X \in R^{m \times m}\)</span> is left singular matrix, <span class="math inline">\(\Sigma \in R^{m \times n} = \begin{bmatrix}  \Sigma_n \\  0  \end{bmatrix} \mbox{ with }  \Sigma_n = \mbox{diag}(\sigma_1, \ldots, \sigma_n)\)</span>, and <span class="math inline">\(V \in R^{m \times n}\)</span> is the right singular matrix. Let <span class="math inline">\(Z = Y^T B^T X\)</span>. Now <span class="math inline">\(Z\)</span> is a rectangular matrix with orthonormal rows (<span class="math inline">\(Z Z^T = I\)</span>) as <span class="math inline">\(B^T B = I\)</span>. Now we have,</p>
<p><span class="math display">\[
\begin{aligned}
  \mathrm{tr}(A Q^T B^T) &amp;= \mathrm{tr}(X \Sigma Y^T B^T)  =  \mathrm{tr}(Y^T B^T X \Sigma)
  = \mathrm{tr}(Z\Sigma) \\
  &amp;= \sum_{i=1}^{n} z_{ii}\sigma_i \leq \sum_{i=1}^{n} \sigma_i.
  \end{aligned}
\]</span> The upper bound is obtained when <span class="math inline">\(Z=I\)</span> and thus <span class="math inline">\(B=X Y^T\)</span>.</p>
</div>
<div id="proposition-ii" class="section level2">
<h2>Proposition II</h2>
<p>Let <span class="math inline">\(A \in \mathbb{R}^{m \times n}\)</span> with rank <span class="math inline">\(n\)</span> and SVD of <span class="math inline">\(A^T B = X \Sigma Y^T\)</span>. Among all orthogonal matrices <span class="math inline">\(Q\)</span>, the Forbenius norm <span class="math inline">\(\|A - B Q^T\|^2_F\)</span> is minimized when <span class="math inline">\(Q = X Y^T\)</span>.</p>
<p><span class="math display">\[
\begin{aligned}
  \min \|A - B Q^T \|^2_F &amp;= \mathrm{tr}\left( A - BQ^T \right)^T (A - B Q^T) \\
  &amp;= \mathrm{tr}(A^T A) + \mathrm{tr}(B^T B) - 2 \mathrm{tr}(A^T B Q^T).  
\end{aligned}
\]</span> This is equivalent to maximizing <span class="math inline">\(\mathrm{tr}(A^T B Q^T)\)</span>. Let SVD of <span class="math inline">\(A^T B = X \Sigma Y^T\)</span>, where <span class="math inline">\(\Sigma = \mbox{diag}(\sigma_1, \ldots, \sigma_n)\)</span>. We define an orthogonal matrix $Z = Y^T Q X $. Now we have,</p>
<p><span class="math display">\[
\begin{aligned}
  \mathrm{tr}(A^T B Q^T) &amp;= \mathrm{tr}(X \Sigma Y^T Q^T)  =  \mathrm{tr}(Y^T Q^T X \Sigma)
  = \mathrm{tr}(Z\Sigma)\\
  &amp;= \sum_{i=1}^{n} z_{ii}\sigma_i \leq \sum_{i=1}^{p} \sigma_i.
\end{aligned}
\]</span> The upper bound is obtained when <span class="math inline">\(Z=I\)</span> and thus <span class="math inline">\(Q = X Y^T\)</span>.</p>
</div>
<div id="proposition-iii" class="section level2">
<h2>Proposition III</h2>
<p>For a set of <span class="math inline">\(n\)</span> matrices <span class="math inline">\(A_1,A_2, \ldots, A_n\)</span>, where <span class="math inline">\(A_i \in \mathbb{R}^{k \times k}\)</span>, the orthogonal matrix <span class="math inline">\(Q \in \mathbb{R}^{k \times k}\)</span> minimizing the Forbenius norm <span class="math inline">\(\sum_{i=1}^n \|A_i- Q \|^2_F\)</span> is given by <span class="math inline">\(Q = X Y^T\)</span>, where SVD of <span class="math inline">\(\sum_{i=1}^n A_i = X \Sigma Y^T\)</span>.</p>
<p>Let us first consider <span class="math inline">\(i = 1\)</span> case. We want to minimize the objective function: <span class="math display">\[
 \mathcal{F}(Q) = \|A_1- Q \|^2_F \mbox{ subject to } Q^T Q = I.
\]</span></p>
<p>The objective function can be reformulated as</p>
<p><span class="math display">\[
 \mathcal{F}(Q) =  \|A_1 - Q\|^2_{F} =  \mathrm{tr}\left(A_1^T A_1 - 2 A_1^T Q + Q^T Q \right).
\]</span></p>
<p>Let <span class="math inline">\(\Phi\)</span> be a matrix with Lagrange multipliers for constraint <span class="math inline">\(Q^T Q - I = 0\)</span>. The Lagrange <span class="math inline">\(\mathcal{L}\)</span> is</p>
<p><span class="math display">\[
 \mathcal{L}(Q) = \mathrm{tr}\left(A_1^T A_1 - 2 A_1^T Q + Q^T Q \right) +
 \mathrm{tr}\left( \Phi(Q^T Q - I) \right).
\]</span></p>
<p>The partial derivative of <span class="math inline">\(\mathcal{L}\)</span> with respect to <span class="math inline">\(Q\)</span> gives <span class="math display">\[
\begin{aligned}
    \frac{\partial \mathcal{L}}{\partial Q} &amp;= -2 A_1 + Q ( \Phi^T + \Phi) \\
    A_1 &amp;= Q \left( \frac{\Phi^T + \Phi}{2} \right) \\
    Q &amp;= A_1 \left(\frac{\Phi^T + \Phi}{2} \right)^{-1}.
\end{aligned}
\]</span></p>
<p>Given that the <span class="math inline">\(Q\)</span> is orthogonal, we have</p>
<p><span class="math display">\[
\begin{aligned}
    A_1^T A_1 &amp;= \left(\frac{\Phi^T + \Phi}{2} \right)^2 \\
    \left(\frac{\Phi^T + \Phi}{2} \right) &amp;= (A_1^T A_1)^{1/2}.
\end{aligned}
\]</span></p>
<p>Thus for <span class="math inline">\(i = 1\)</span>, <span class="math inline">\(Q = A_1 (A_1^T A_1)^{-1/2}\)</span>. Now for <span class="math inline">\(i = 2\)</span>, we have</p>
<p><span class="math display">\[
\begin{aligned}
    \frac{\partial \mathcal{L}}{\partial Q} &amp;= -2 A_1 - 2 A_2 + Q ( \Phi^T + \Phi) \\
    A_1 + A_2 &amp;= Q \left(\frac{\Phi^T + \Phi}{2} \right) \\
    Q &amp;= (A_1 + A_2) \left(\frac{\Phi^T + \Phi}{2} \right)^{-1} \\
      &amp;= (A_1 + A_2) \left( (A_1 + A_2)^T (A_1 + A_2) \right)^{-1/2}.
\end{aligned}
\]</span></p>
<p>Now for <span class="math inline">\(i = n\)</span>, we have</p>
<p><span class="math display">\[
\begin{aligned}
  Q &amp;= M ( M^T M)^{-1/2} \mbox{ where } M = \sum_{i=1}^n A_i = X \Sigma Y^T \\
    &amp;=  X \Sigma Y^T ( Y \Sigma^2 Y^T)^{-1/2} \\
    &amp;= X Y^T.
\end{aligned}
\]</span></p>
</div>
<div id="iterative-update" class="section level2">
<h2>Iterative update</h2>
<p>Using these three propositions, we iteratively update <span class="math inline">\(U_i\)</span>, <span class="math inline">\(\Delta_i\)</span>, and <span class="math inline">\(V\)</span>. The steps of the iterative algorithm are shown below.</p>
<ol style="list-style-type: decimal">
<li>Input: <span class="math inline">\(D_i, i={1 \ldots N}\)</span></li>
<li>Output: <span class="math inline">\(U_i,\Delta_i\)</span>, and <span class="math inline">\(V\)</span>, where <span class="math inline">\(U_i^T U_i = I\)</span> and <span class="math inline">\(V^T V = V V^T = I\)</span></li>
<li>Initialize <span class="math inline">\(U_i^{k}\)</span>, <span class="math inline">\(\Delta_i^{k}\)</span>, and <span class="math inline">\(V^{k}\)</span>. Compute <span class="math inline">\(\epsilon^{k,k,k} = {\sum^{N}_{i=1}\|D_i - U_i^{k} \Delta_i^{k} {V^{k}}^{\!T}\|^{2}}_F\)</span></li>
<li>Update <span class="math inline">\(\mathbf{U_i^{k+1}}\)</span>:<br />
   <span class="math inline">\(U_i^{k+1} = Z Y^T\)</span>, where SVD of <span class="math inline">\(D_i V^{k} \Delta_i^{k} = Z \Sigma Y^T\)</span>. Compute <span class="math inline">\(\epsilon^{k+1,k,k}\)</span><br />
   If <span class="math inline">\(\epsilon^{k+1,k,k} &lt; \epsilon^{k,k,k}\)</span>:<br />
      <span class="math inline">\(U_i \leftarrow U_i^{k+1}\)</span>.</li>
<li>Update <span class="math inline">\(\mathbf{\Delta_i^{k+1}}\)</span>:<br />
   <span class="math inline">\(\mathbf{\Delta_i^{k+1}} = \mbox{diag}( (U_i^{k+1})^T D_i V^k)\)</span>. Compute <span class="math inline">\(\epsilon^{k+1,k+1,k}\)</span><br />
   If <span class="math inline">\(\epsilon^{k+1,k+1,k} &lt; \epsilon^{k+1,k,k}\)</span>:<br />
      <span class="math inline">\(\Delta_i \leftarrow \Delta_i^{k+1}\)</span></li>
<li>Update <span class="math inline">\(\mathbf{V^{k+1}}\)</span>:<br />
   <span class="math inline">\(V^{k+1} = M Q^T\)</span>, where SVD of <span class="math inline">\(\sum_{i}^N D_i^T U_i^{k+1} \Delta_i^{k+1} = M \Phi Q^T\)</span>. Compute <span class="math inline">\(\epsilon^{k+1,k+1,k+1}\)</span><br />
   If <span class="math inline">\(\epsilon^{k+1,k+1,k+1} &lt; \epsilon^{k+1,k+1,k}\)</span>:<br />
      <span class="math inline">\(V \leftarrow V^{k+1}\)</span></li>
<li>Repeat steps 4-6 until convergence.</li>
</ol>
<p>Our iterative approach is a block-coordinate descent algorithm. In gradient descent, we have the general update: <span class="math display">\[
\theta_{t+1} = \theta_t - \eta \nabla \mathcal{F}(\theta_t),
\]</span> where <span class="math inline">\(t\)</span> is the iteration counter, <span class="math inline">\(\eta\)</span> is the learning rate and <span class="math inline">\(\nabla \mathcal{F} (\theta)\)</span> is the gradient of the cost function. In A-SBF, the gradient of the cost function with respect to <span class="math inline">\(U\)</span> is <span class="math inline">\(-2 D V \Delta\)</span>. So we have</p>
<p><span class="math display">\[
  U_{t+1} = U_t + \eta D V \Delta.
\]</span> By setting <span class="math inline">\(\eta = I - U_t (D V \Delta)^{-1}\)</span>, we have <span class="math inline">\(U_{t+1} = D V \Delta\)</span>. Since we require orthonormal columns, we find the closest orthogonal matrix to <span class="math inline">\(D V \Delta\)</span>, and set the final value of <span class="math inline">\(U_{t+1} = Z Y^T\)</span>, where SVD of <span class="math inline">\(DV\Delta = Z \Sigma Y^T\)</span>. This approach employs orthogonal Procrustes solution along with the gradient descent algorithm. We can also achieve this by directly setting <span class="math inline">\(\eta = \frac{Z Y^T - U_t}{D V \Delta}\)</span>, so that <span class="math inline">\(U_{t+1}\)</span> has all the properties we need. The learning rate determines the size of the steps. If the value of <span class="math inline">\(U_t\)</span> is very different from <span class="math inline">\(Z Y^T\)</span>, <span class="math inline">\(\eta\)</span> will be high, and we take larger steps. As it becomes closer, the learning rate also decreases. We have a similar case for updating <span class="math inline">\(V\)</span> and <span class="math inline">\(\Delta\)</span>.</p>
</div>
<div id="examples" class="section level2">
<h2>Examples</h2>
<div id="optimizing-a-sbf-error" class="section level3">
<h3>Optimizing A-SBF error</h3>
<p>Let us optimize the factorization error using the <code>optimizeFactorization</code> function for the three cases of A-SBF computation.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1231</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>mymat <span class="ot">&lt;-</span> <span class="fu">createRandomMatrices</span>(<span class="at">n =</span> <span class="dv">4</span>, <span class="at">ncols =</span> <span class="dv">3</span>, <span class="at">nrows =</span> <span class="dv">4</span><span class="sc">:</span><span class="dv">6</span>)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>asbf <span class="ot">&lt;-</span> <span class="fu">SBF</span>(<span class="at">matrix_list =</span> mymat, <span class="at">approximate =</span> <span class="cn">TRUE</span>)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>asbf_inv <span class="ot">&lt;-</span> <span class="fu">SBF</span>(<span class="at">matrix_list =</span> mymat, <span class="at">weighted =</span> <span class="cn">TRUE</span>, <span class="at">approximate =</span> <span class="cn">TRUE</span>)</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>asbf_cor <span class="ot">&lt;-</span> <span class="fu">SBF</span>(<span class="at">matrix_list =</span> mymat, <span class="at">approximate =</span> <span class="cn">TRUE</span>, <span class="at">transform_matrix =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<p>Depending upon the data matrix and initial values of <span class="math inline">\(U_i\)</span>, <span class="math inline">\(\Delta_i\)</span>, and <span class="math inline">\(V\)</span>, optimization could take some time.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>myopt <span class="ot">&lt;-</span> <span class="fu">optimizeFactorization</span>(mymat, asbf<span class="sc">$</span>u_ortho, asbf<span class="sc">$</span>delta, asbf<span class="sc">$</span>v)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>myopt_inv <span class="ot">&lt;-</span> <span class="fu">optimizeFactorization</span>(mymat, asbf_inv<span class="sc">$</span>u_ortho, asbf_inv<span class="sc">$</span>delta,</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>                                   asbf_inv<span class="sc">$</span>v)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>myopt_cor <span class="ot">&lt;-</span> <span class="fu">optimizeFactorization</span>(mymat, asbf_cor<span class="sc">$</span>u_ortho, asbf_cor<span class="sc">$</span>delta,</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>                                   asbf_cor<span class="sc">$</span>v)</span></code></pre></div>
<p>The number of iteration taken for optimizing and new factorization error:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&quot;For asbf, # iteration =&quot;</span>, myopt<span class="sc">$</span>error_pos, <span class="st">&quot;final error =&quot;</span>, myopt<span class="sc">$</span>error)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; For asbf, # iteration = 220 final error = 1411.555</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">For asbf inv, # iteration =&quot;</span>, myopt_inv<span class="sc">$</span>error_pos, <span class="st">&quot;final error =&quot;</span>,</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    myopt_inv<span class="sc">$</span>error)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; For asbf inv, # iteration = 202 final error = 1411.555</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">For asbf cor, # iteration =&quot;</span>, myopt_cor<span class="sc">$</span>error_pos, <span class="st">&quot;final error =&quot;</span>,</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>    myopt_cor<span class="sc">$</span>error)</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; For asbf cor, # iteration = 196 final error = 1411.555</span></span></code></pre></div>
<pre><code>#&gt; After optimization, for all three A-SBF factorizations, the final error
#&gt; is the same (up to 2 decimals).
#&gt; The final error is 1411.56</code></pre>
</div>
<div id="using-different-initial-values" class="section level3">
<h3>Using different initial values</h3>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1231</span>)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>mymat <span class="ot">&lt;-</span> <span class="fu">createRandomMatrices</span>(<span class="at">n =</span> <span class="dv">4</span>, <span class="at">ncols =</span> <span class="dv">3</span>, <span class="at">nrows =</span> <span class="dv">4</span><span class="sc">:</span><span class="dv">6</span>)</span></code></pre></div>
<ol style="list-style-type: decimal">
<li>Let us initialize the <code>optimizeFactorization</code> function with a random orthogonal matrix and check the final optimization error. The <span class="math inline">\(V\)</span> matrix estimated from the <code>mymat</code> matrix has a dimension of <span class="math inline">\(3 \times 3\)</span>. First we will create a random <span class="math inline">\(3 \times 3\)</span> matrix and obtain an orthogonal matrix based on this.</li>
</ol>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">111</span>)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>rand_mat <span class="ot">&lt;-</span> <span class="fu">createRandomMatrices</span>(<span class="at">n =</span> <span class="dv">1</span>, <span class="at">ncols =</span> <span class="dv">3</span>, <span class="at">nrows =</span> <span class="dv">3</span>)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">Rank is:&quot;</span>, <span class="fu">qr</span>(rand_mat[[<span class="dv">1</span>]])<span class="sc">$</span>rank,<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Rank is: 3</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="fu">dim</span>(rand_mat[[<span class="dv">1</span>]])</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 3 3</span></span></code></pre></div>
<p>Get an orthogonal <span class="math inline">\(V\)</span> matrix using SVD. We will set <span class="math inline">\(V\)</span> as the right basis matrix from the SVD.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>mysvd <span class="ot">&lt;-</span> <span class="fu">svd</span>(rand_mat[[<span class="dv">1</span>]])</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>randV <span class="ot">&lt;-</span> mysvd<span class="sc">$</span>v</span></code></pre></div>
<p>Now for this <span class="math inline">\(V\)</span>, we will first compute <span class="math inline">\(U_i\)</span>’s and <span class="math inline">\(\Delta_i\)</span> for different <span class="math inline">\(D_i\)</span> matrices in the <code>mymat</code>. We achieve this by solving the linear equations: <span class="math inline">\(D_i = U_i \Delta_i V^T\)</span> for <span class="math inline">\(i = 1, \ldots, 4\)</span>. We then orthonormalize the columns of <span class="math inline">\(U_i\)</span> using Proposition I.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co"># get Ui and Delta for this newV</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>out <span class="ot">&lt;-</span> <span class="fu">computeUDelta</span>(mymat, randV)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(out)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;u&quot;       &quot;u_ortho&quot; &quot;d&quot;       &quot;d_ortho&quot; &quot;error&quot;</span></span></code></pre></div>
<p>The initial decomposition error is :</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="fu">calcDecompError</span>(mymat, out<span class="sc">$</span>u_ortho, out<span class="sc">$</span>d, randV)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 22879.08</span></span></code></pre></div>
<p>Now we will try to optimize using the new random <span class="math inline">\(V\)</span> and corresponding <span class="math inline">\(U_i\)</span>’s and <span class="math inline">\(\Delta_i\)</span>’s.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>newopt <span class="ot">&lt;-</span> <span class="fu">optimizeFactorization</span>(mymat, out<span class="sc">$</span>u_ortho, out<span class="sc">$</span>d, randV)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Number of updates taken</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>newopt<span class="sc">$</span>error_pos</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 220</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="co"># New error</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>newopt<span class="sc">$</span>error</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 1411.555</span></span></code></pre></div>
<p>We achieve the same factorization error (<code>1411.5550218</code>) after the <code>optimizeFactorization</code> function call.</p>
<ol start="2" style="list-style-type: decimal">
<li>Now instead of the right basis matrix from the SVD, we will set <span class="math inline">\(V\)</span> as the left basis matrix.</li>
</ol>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>mysvd <span class="ot">&lt;-</span> <span class="fu">svd</span>(rand_mat[[<span class="dv">1</span>]])</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>randV <span class="ot">&lt;-</span> mysvd<span class="sc">$</span>u</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="fu">dim</span>(randV)</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 3 3</span></span></code></pre></div>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co"># get Ui and Delta for this newV</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>out <span class="ot">&lt;-</span> <span class="fu">computeUDelta</span>(mymat, randV)</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="fu">calcDecompError</span>(mymat, out<span class="sc">$</span>u_ortho, out<span class="sc">$</span>d, randV)</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 13903.45</span></span></code></pre></div>
<p>Now we will try to optimize with these matrices as our initial values.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>newopt <span class="ot">&lt;-</span> <span class="fu">optimizeFactorization</span>(mymat, out<span class="sc">$</span>u_ortho, out<span class="sc">$</span>d, randV)</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Number of updates taken</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>newopt<span class="sc">$</span>error_pos</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 283</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="co"># New error</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>newopt<span class="sc">$</span>error</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 1411.555</span></span></code></pre></div>
<p>Again we get the same decomposition error after optimizing.</p>
<ol start="3" style="list-style-type: decimal">
<li>Instead of initial value being an orthogonal matrix, we will initialize <span class="math inline">\(U_i\)</span>’s, <span class="math inline">\(\Delta_i\)</span>, and <span class="math inline">\(V\)</span> with random matrices such that it does not guarantee</li>
</ol>
<ul>
<li>orthogonal property for <span class="math inline">\(V\)</span> and</li>
<li>orthonormal columns for <span class="math inline">\(U_i\)</span>’s.</li>
</ul>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">111</span>)</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="co"># new random v</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>newv <span class="ot">&lt;-</span> <span class="fu">createRandomMatrices</span>(<span class="at">n =</span> <span class="dv">1</span>, <span class="at">ncols =</span> <span class="dv">3</span>, <span class="at">nrows =</span> <span class="dv">3</span>)[[<span class="dv">1</span>]]</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="co"># seed value</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>k <span class="ot">&lt;-</span> <span class="dv">2392</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>newu <span class="ot">&lt;-</span> newd <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="fu">names</span>(mymat)){</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>  myrow <span class="ot">&lt;-</span> <span class="fu">nrow</span>(mymat[[i]])</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>  mycol <span class="ot">&lt;-</span> <span class="fu">ncol</span>(mymat[[i]])</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set.seed</span>(k)</span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>  <span class="co"># new random u_i</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>  newu[[i]] <span class="ot">&lt;-</span> <span class="fu">createRandomMatrices</span>(<span class="at">n =</span> <span class="dv">1</span>, <span class="at">ncols =</span> mycol, <span class="at">nrows =</span> myrow)[[<span class="dv">1</span>]]</span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set.seed</span>(k<span class="sc">*</span><span class="dv">2</span>)</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>  <span class="co"># new random d_i</span></span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>  newd[[i]] <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">1000</span>, <span class="at">size =</span> mycol)</span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>  newmat <span class="ot">&lt;-</span> newu[[i]] <span class="sc">%*%</span> <span class="fu">diag</span>(newd[[i]]) <span class="sc">%*%</span> <span class="fu">t</span>(newv)</span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="sc">!</span><span class="fu">qr</span>(newmat)<span class="sc">$</span>rank <span class="sc">==</span> mycol)</span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>    <span class="fu">cat</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">New matrix does not have full column rank&quot;</span>)</span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a>  k <span class="ot">=</span> k<span class="sc">+</span><span class="dv">1</span></span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a>error <span class="ot">&lt;-</span> <span class="fu">calcDecompError</span>(mymat, newu, newd, newv)</span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">Initial error = &quot;</span>, error,<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; Initial error =  2.062531e+15</span></span></code></pre></div>
<p>We see a very high factorization error because of the random initialization.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>newopt <span class="ot">&lt;-</span> <span class="fu">optimizeFactorization</span>(mymat, newu, newd, newv)</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>newopt<span class="sc">$</span>error_pos</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 142</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>newopt<span class="sc">$</span>error</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 1411.555</span></span></code></pre></div>
<p>Again, we get the same factorization error after optimizing. Try changing the seed value and compare the results.</p>
<p>This shows that the iterative update procedure converges and achieves the same decomposition error regardless of the initial values.</p>
</div>
<div id="estimating-svd" class="section level3">
<h3>Estimating SVD</h3>
<p>We will further demonstrate the case for <span class="math inline">\(N=1\)</span> when we have just one matrix. The <code>optimizeFactorization</code> function gives <span class="math inline">\(U_i\)</span>’s with orthonormal column, <span class="math inline">\(\Delta_i\)</span> a diagonal matrix, and an orthogonal <span class="math inline">\(V\)</span>. If the function converges, the results should be identical to a standard SVD, except for the sign changes corresponding to <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> columns. So we will compare the results from the <code>optimizeFactorization</code> function with the standard SVD output. Let us generate one example matrix say <code>newmat</code>.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">171</span>)</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>newmat <span class="ot">&lt;-</span> <span class="fu">createRandomMatrices</span>(<span class="at">n =</span> <span class="dv">1</span>, <span class="at">ncols =</span> <span class="dv">3</span>, <span class="at">nrows =</span> <span class="dv">3</span>)</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>newmat</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $mat1</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1] [,2] [,3]</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]   41   10    6</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,]   64   85    8</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [3,]   82   87   57</span></span></code></pre></div>
<p>We will estimate the SVD of <code>newmat</code> using our iterative update function from another random matrix with the same dimension.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">253</span>)</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>randmat_new <span class="ot">&lt;-</span> <span class="fu">createRandomMatrices</span>(<span class="at">n =</span> <span class="dv">1</span>, <span class="at">ncols =</span> <span class="dv">3</span>, <span class="at">nrows =</span> <span class="dv">3</span>)</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>randmat_new</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $mat1</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1] [,2] [,3]</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]   94   30   77</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,]   60   35  100</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [3,]   67   84   58</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>newsvd <span class="ot">&lt;-</span> <span class="fu">svd</span>(randmat_new[[<span class="dv">1</span>]])</span></code></pre></div>
<p>Let us create a list for the <span class="math inline">\(u\)</span> and <span class="math inline">\(\delta\)</span> matrices we just obtained from the SVD of the random matrix. This allows us to use these matrices as the initial values for the <code>optimizeFactorization</code> function.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>newu <span class="ot">&lt;-</span> newd <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>newu[[<span class="fu">names</span>(randmat_new)]] <span class="ot">&lt;-</span> newsvd<span class="sc">$</span>u</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>newd[[<span class="fu">names</span>(randmat_new)]] <span class="ot">&lt;-</span> newsvd<span class="sc">$</span>d</span></code></pre></div>
<p>The factorization error</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="fu">calcDecompError</span>(newmat, newu, newd, newsvd<span class="sc">$</span>v)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 19465</span></span></code></pre></div>
<p>Let us optimize.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>opt_new <span class="ot">&lt;-</span> <span class="fu">optimizeFactorization</span>(newmat, newu, newd, newsvd<span class="sc">$</span>v)</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st"> # of updates:&quot;</span>, opt_new<span class="sc">$</span>error_pos,<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  # of updates: 235</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>opt_new<span class="sc">$</span>error</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 0.0006461125</span></span></code></pre></div>
<p>Error is close to zero. Let us compare the original matrix with the reconstructed matrix based on the estimated <span class="math inline">\(u\)</span>, <span class="math inline">\(d\)</span> and <span class="math inline">\(v\)</span> using the <code>optimizeFactorization</code> function.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>newmat</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; $mat1</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1] [,2] [,3]</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]   41   10    6</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,]   64   85    8</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [3,]   82   87   57</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>opt_new<span class="sc">$</span>u[[<span class="dv">1</span>]] <span class="sc">%*%</span> <span class="fu">diag</span>(opt_new<span class="sc">$</span>d[[<span class="dv">1</span>]]) <span class="sc">%*%</span> <span class="fu">t</span>(opt_new<span class="sc">$</span>v)</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;          [,1]     [,2]      [,3]</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,] 40.99550 10.00886  5.988544</span></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,] 64.01211 84.99162  7.993461</span></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [3,] 81.99163 87.00424 57.008260</span></span></code></pre></div>
<p>The estimated value is very close.</p>
<p>We can further improve our estimate by decreasing the tolerance parameter (<code>tol</code>) in the optimization function.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>opt_new1 <span class="ot">&lt;-</span> <span class="fu">optimizeFactorization</span>(newmat, newu, newd, newsvd<span class="sc">$</span>v, <span class="at">tol =</span> <span class="fl">1e-21</span>)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st"> # of updates:&quot;</span>, opt_new1<span class="sc">$</span>error_pos,<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;  # of updates: 673</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>opt_new1<span class="sc">$</span>error</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 9.156226e-14</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>opt_new1<span class="sc">$</span>u[[<span class="dv">1</span>]] <span class="sc">%*%</span> <span class="fu">diag</span>(opt_new1<span class="sc">$</span>d[[<span class="dv">1</span>]]) <span class="sc">%*%</span> <span class="fu">t</span>(opt_new1<span class="sc">$</span>v)</span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1] [,2] [,3]</span></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]   41   10    6</span></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,]   64   85    8</span></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [3,]   82   87   57</span></span></code></pre></div>
<p>The reconstructed matrix is the same as the original matrix. Let us compare the <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> with that from the standard SVD.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>newmat_svd <span class="ot">&lt;-</span> <span class="fu">svd</span>(newmat[[<span class="dv">1</span>]])</span></code></pre></div>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>newmat_svd<span class="sc">$</span>u</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;            [,1]       [,2]        [,3]</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,] -0.2067092  0.1766241 -0.96232802</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,] -0.6071027 -0.7944740 -0.01541011</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [3,] -0.7672664  0.5810465  0.27145407</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>opt_new1<span class="sc">$</span>u[[<span class="dv">1</span>]]</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;            [,1]       [,2]        [,3]</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,] -0.2067092 -0.1766241  0.96232803</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,] -0.6071027  0.7944740  0.01541009</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [3,] -0.7672664 -0.5810465 -0.27145405</span></span></code></pre></div>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>newmat_svd<span class="sc">$</span>v</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;            [,1]       [,2]       [,3]</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,] -0.6458388  0.1264120 -0.7529358</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,] -0.7054605 -0.4758901  0.5252181</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [3,] -0.2919209  0.8703727  0.3965270</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>opt_new1<span class="sc">$</span>v</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;            [,1]       [,2]       [,3]</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,] -0.6458388 -0.1264120  0.7529358</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,] -0.7054605  0.4758901 -0.5252181</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [3,] -0.2919209 -0.8703727 -0.3965269</span></span></code></pre></div>
<p>The results agree!</p>
</div>
</div>
</div>
<div id="cross-species-gene-expression-analysis-using-a-sbf" class="section level1">
<h1>Cross-species gene expression analysis using A-SBF</h1>
<p>For cross-species gene expression datasets, we estimate the common space <span class="math inline">\(V\)</span> based on correlation (<span class="math inline">\(R_i\)</span>) between column phenotypes (such as tissues, cell types, etc.) within a species. In our study, we have shown that the inter-tissue gene expression correlation is similar across species. Let <span class="math inline">\(X_i \in \mathbb{R}^{m_i \times k}\)</span> be a standardized gene expression matrix where <span class="math inline">\(X_i = C_i D_i {S_i}^{-1}\)</span>. Here <span class="math inline">\(C_i = I_{m_i} - {m_i}^{-1} 1_{m_i} {1_{m_i}}^T\)</span> is a centering matrix and <span class="math inline">\(S_i = \mbox{diag}(s_1,\ldots,s_k)\)</span> is a diagonal scaling matrix, where <span class="math inline">\(s_p\)</span> is the standard deviation of <span class="math inline">\(p\)</span>-th column of <span class="math inline">\(D_i\)</span>. The matrix <span class="math inline">\(X_i\)</span> is a matrix with columns of <span class="math inline">\(D_i\)</span> mean-centered and scaled by the standard deviation. The correlation between expression profiles of <span class="math inline">\(k\)</span> tissue types in species <span class="math inline">\(i\)</span> is given by <span class="math inline">\(R_i = X_i^T X_i/m_i\)</span>. We then define an expected correlation matrix (<span class="math inline">\(\mathbb{E}(R_i)\)</span>) across <span class="math inline">\(N\)</span> species as <span class="math inline">\(M\)</span>, where <span class="math inline">\(M\)</span> is defined as</p>
<p><span class="math display">\[
  M = \frac{\sum_{i=1}^{N} R_i}{N}.
\]</span></p>
<p>The shared right basis matrix <span class="math inline">\(V\)</span> capturing the inter-tissue gene expression correlation is determined from the eigenvalue decomposition of <span class="math inline">\(M\)</span>, where <span class="math inline">\(M=V \Theta V^T\)</span>. Once the <span class="math inline">\(V\)</span> and <span class="math inline">\(\Delta_i\)</span> are estimated using the SBF factorization, we compute <span class="math inline">\(U_i\)</span> with orthonormal columns using proposition I. The estimated <span class="math inline">\(V\)</span> space captures inter-tissue gene expression correlation relationship. For gene expression analysis, if we want the shared space to represent inter-sample correlation relationship, we do not update/change <span class="math inline">\(V\)</span> while optimizing the factorization error. In such cases, while reducing the factorization error we set <code>optimizeV = FALSE</code> in the <code>optimizeFactorization</code> function.</p>
<div id="usage-examples" class="section level2">
<h2>Usage examples</h2>
<p>Let us load the SBF package’s in-built gene expression dataset. The dataset contains the average gene expression profile of five similar tissues in three species.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co"># load dataset</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>avg_counts <span class="ot">&lt;-</span> SBF<span class="sc">::</span>TissueExprSpecies</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="co"># check the names of species</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(avg_counts)</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;Homo_sapiens&quot;   &quot;Macaca_mulatta&quot; &quot;Mus_musculus&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co"># head for first species</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>avg_counts[[<span class="fu">names</span>(avg_counts)[<span class="dv">1</span>]]][<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>]</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;                 hsapiens_brain hsapiens_heart hsapiens_kidney</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; ENSG00000000003         2.3109         1.9414          5.2321</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; ENSG00000000005         0.0254         0.2227          0.5317</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; ENSG00000000419         5.2374         5.3901          5.5659</span></span></code></pre></div>
<p>The number of genes annotated in different species is different. As a result, the number of rows (genes) in the expression data will be different for different species.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sapply</span>(avg_counts, dim)</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      Homo_sapiens Macaca_mulatta Mus_musculus</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]        58676          30807        54446</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,]            5              5            5</span></span></code></pre></div>
<p>Let us compute A-SBF with inter-tissue correlation.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co"># A-SBF call using correlation matrix</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>asbf_cor <span class="ot">&lt;-</span> <span class="fu">SBF</span>(<span class="at">matrix_list =</span> avg_counts, <span class="at">check_col_matching =</span> <span class="cn">TRUE</span>,</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>                <span class="at">col_index =</span> <span class="dv">2</span>, <span class="at">approximate =</span> <span class="cn">TRUE</span>, <span class="at">transform_matrix =</span> <span class="cn">TRUE</span>)</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span class="co"># decomposition error</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>asbf_cor<span class="sc">$</span>error</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 65865.92</span></span></code></pre></div>
<p>Optimize factorization to reduce decomposition error but by not updating <span class="math inline">\(V\)</span>.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>myopt_gef <span class="ot">&lt;-</span> <span class="fu">optimizeFactorization</span>(avg_counts, asbf_cor<span class="sc">$</span>u_ortho, asbf_cor<span class="sc">$</span>delta,</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>                                   asbf_cor<span class="sc">$</span>v, <span class="at">optimizeV =</span> <span class="cn">FALSE</span>)</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(myopt_gef)</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] &quot;u&quot;         &quot;v&quot;         &quot;d&quot;         &quot;error&quot;     &quot;error_pos&quot; &quot;error_vec&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="co"># new error</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>myopt_gef<span class="sc">$</span>error</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 63540.08</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="co"># number of iterations</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>myopt_gef<span class="sc">$</span>error_pos</span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] 10</span></span></code></pre></div>
<p>The number of iterations taken to optimize = 10.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="fu">identical</span>(asbf_cor<span class="sc">$</span>v, myopt_gef<span class="sc">$</span>v)</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>Check whether estimated <span class="math inline">\(U_i\)</span>’s have orthonormal columns.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="fu">zapsmall</span>(<span class="fu">t</span>(<span class="fu">as.matrix</span>(myopt_gef<span class="sc">$</span>u[[<span class="fu">names</span>(myopt_gef<span class="sc">$</span>u)[<span class="dv">1</span>]]])) <span class="sc">%*%</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>           <span class="fu">as.matrix</span>(myopt_gef<span class="sc">$</span>u[[<span class="fu">names</span>(myopt_gef<span class="sc">$</span>u)[<span class="dv">1</span>]]]))</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt;      [,1] [,2] [,3] [,4] [,5]</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [1,]    1    0    0    0    0</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [2,]    0    1    0    0    0</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [3,]    0    0    1    0    0</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [4,]    0    0    0    1    0</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a><span class="co">#&gt; [5,]    0    0    0    0    1</span></span></code></pre></div>
</div>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-alter2000singular" class="csl-entry">
Alter, Orly, Patrick O Brown, and David Botstein. 2000. <span>“Singular Value Decomposition for Genome-Wide Expression Data Processing and Modeling.”</span> <em>Proceedings of the National Academy of Sciences</em> 97 (18): 10101–6.
</div>
<div id="ref-alter2003generalized" class="csl-entry">
———. 2003. <span>“<span class="nocase">Generalized singular value decomposition for comparative analysis of genome-scale expression data sets of two different organisms</span>.”</span> <em>Proceedings of the National Academy of Sciences</em> 100 (6): 3351–56.
</div>
<div id="ref-ponnapalli2011higher" class="csl-entry">
Ponnapalli, Sri Priya, Michael A Saunders, Charles F Van Loan, and Orly Alter. 2011. <span>“<span class="nocase">A higher-order generalized singular value decomposition for comparison of global mRNA expression from multiple organisms</span>.”</span> <em>PloS One</em> 6 (12): e28072.
</div>
<div id="ref-tamayo2007metagene" class="csl-entry">
Tamayo, Pablo, Daniel Scanfeld, Benjamin L Ebert, Michael A Gillette, Charles WM Roberts, and Jill P Mesirov. 2007. <span>“<span class="nocase">Metagene projection for cross-platform, cross-species characterization of global transcriptional states</span>.”</span> <em>Proceedings of the National Academy of Sciences</em> 104 (14): 5959–64.
</div>
<div id="ref-van1976generalizing" class="csl-entry">
Van Loan, Charles F. 1976. <span>“Generalizing the Singular Value Decomposition.”</span> <em>SIAM Journal on Numerical Analysis</em> 13 (1): 76–83.
</div>
</div>
</div>

<script type="text/javascript">
window.onload = function() {
  var i, fig = 1, caps = document.getElementsByClassName('caption');
  for (i = 0; i < caps.length; i++) {
    var cap = caps[i];
    if (cap.parentElement.className !== 'figure' || cap.nodeName !== 'P')
      continue;
    cap.innerHTML = '<span>Figure ' + fig + ':</span> ' + cap.innerHTML;
    fig++;
  }
  fig = 1;
  caps = document.getElementsByTagName('caption');
  for (i = 0; i < caps.length; i++) {
    var cap = caps[i];
    if (cap.parentElement.nodeName !== 'TABLE') continue;
    cap.innerHTML = '<span>Table ' + fig + ':</span> ' + cap.innerHTML;
    fig++;
  }
}
</script>


<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
