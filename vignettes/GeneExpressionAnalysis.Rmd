---
title: "Gene expression analysis using A-SBF"
author: "Amal Thomas"
output:
  pdf_document:
    toc: yes
    number_section: yes
  knitr:::html_vignette:
    toc: yes
  html_document:
    toc: yes
    df_print: paged
bibliography: references.bib
vignette: |
  %\VignetteIndexEntry{GeneExpressionAnalysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style>
body {
text-align: justify}
</style>

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

\newcommand{\diag}{\mathrm{diag}}
\newcommand{\tr}{\mathrm{tr}}
\newcommand{\E}{\mathrm{E}}

# Introduction

Consider a set of $k$ real matrices $D_i \in \mathbb{R}^{m_i \times n}$,
each with full column rank.
Each $D_i$ represents the mean expression of $n$ tissues (columns) in species
$i$ with $m_i$ genes (rows) annotated for that species.
The $p\mbox{-th}$ column of each $D_i$ matrix corresponds to the average
gene-expression profile of a functionally equivalent tissue representing
a similar phenotype across species.
The number of rows is different for each $D_i$ matrix, but they all have the
same number of columns.

In A-SBF, we estimate an orthonormal basis $V$ for the common expression
space based on the inter-tissue correlations within each species.
Let $X_i \in \mathbb{R}^{m_i \times n}$ be the standardized gene
expression matrix for species $i$. We can write
\[
X_i = C_iD_i{S_i}^{-1},
\]
where
\[
C_i = I_{m_i} - {m_i}^{-1} 1_{m_i} {1_{m_i}}^T
\]
is a centering matrix and $S_i = \diag(s_1,\ldots,s_n)$ is a diagonal
scaling matrix, where $s_j$ is the standard deviation of $j$-th column
of $D_i$. Within species $i$, the correlation between expression
profiles for the $n$ tissues is
\[
R_i = X_i^TX_i/m_i.
\]
Each $R_i$ matrix has a dimension of $n \times n$ independent of the 
number of genes annotated in the species.
Since the corresponding column of each $D_i$ matrix represents a similar 
phenotype, we can define an expected correlation matrix across the
species:

\[
E = \E(R) = \textstyle\frac{1}{k}\sum_{i=1}^{k} R_i.
\]

The shared right basis matrix $V$ represents the common expression space
and is determined from the eigenvalue decomposition of $E$,
where $E=V \Lambda V^T$.
The right basis matrix $V$ is identical in all the $k$ matrix factorizations,
and the different dimensions of $V$ represent the correlation relationship
between tissues independent of the fact to which species tissues belong.
Once the $V$ is estimated, the species-specific left basis matrix with
orthonormal columns $U_i$ (eigengenes) and the $\Delta_i$ that minimize
the factorization error are computed 

```{r setup}
# load SBF package
library(SBF)
```

Additional package required for the vignette
```{r}
pkgs <- c("data.table", "dplyr", "matrixStats")
require_install <- pkgs[!(pkgs %in% row.names(installed.packages()))]
if (length(require_install))
  install.packages(require_install)
suppressPackageStartupMessages({
  library(data.table)
  library(dplyr)
  library(matrixStats)
})
```

Download the processed counts file from:
Read RNA-Seq counts data
```{r}
species <- c("Homo_sapiens", "Pan_troglodytes", "Macaca_mulatta",
             "Mus_musculus", "Rattus_norvegicus", "Bos_taurus",
             "Sus_scrofa","Gallus_gallus")
# common tissues present in all 8 species
tissues <-  c("brain", "heart", "kidney", "liver", "lung", "testis")
counts_path <- "/home/master/Dropbox/0.Analysis/0.paper/counts/"
```


# read gene expression profiles

```{r}
counts_list <- metadata_list <- list()
for (sp in species) {
  counts <- fread(paste0(counts_path, sp, "_logTPM.tsv"), sep = "\t",
                  header = T, data.table = FALSE, nThread = 4)
  row.names(counts) <- counts$V1
  counts$V1 <- NULL
  col_fields <- tstrsplit(colnames(counts),"_")
  metadata <- data.frame(
      project = col_fields[[1]],
      species = col_fields[[2]],
      tissue = col_fields[[3]],
      gsm = col_fields[[4]],
      name = colnames(counts),
      stringsAsFactors = F)
  metadata_sel <- metadata[metadata$tissue %in% tissues, , drop = F]
  counts_sel <- counts[ , colnames(counts) %in% metadata_sel$name, drop = F]
  metadata_sel$ref <- seq_len(nrow(metadata_sel))
  metadata_sel$key <- paste0(metadata_sel$species, "_", metadata_sel$tissue)

  counts_list[[sp]] <- counts_sel
  metadata_list[[sp]] <- metadata_sel

}
```

Dimensions and number of profiles for different species

```{r}
sapply(counts_list, dim)
```

Now, for each species, let us compute average expression profile for each tissue.

```{r}
#function to calcuate mean expression values for each tissue/group
calcAvgCounts <- function(counts, metadata, ndecimal = 4) {
   require(dplyr)
   counts.avg <- list()
   if ("key" %in% colnames(metadata)) {
     for (species.organ in sort(unique(metadata$key))) {
        no.of.libs <- length(colnames(counts)[grepl(species.organ,
                                                    colnames(counts))])
        if (no.of.libs > 1)
           counts.avg[[species.organ]] <- round(rowMeans(counts[, colnames(counts)[
                                   grepl(species.organ, colnames(counts))]],
                                   dim=1), ndecimal)
        else if (no.of.libs == 1)
           counts.avg[[species.organ]] <- round(counts[, colnames(counts)[grepl(
                              species.organ, colnames(counts))], drop = T], ndecimal)
     }
     avg.counts <- as.data.frame(counts.avg %>% bind_cols())
     row.names(avg.counts) <- row.names(counts)
     return(avg.counts)
   }else {
     stop("'key' column not found in the metadata!Exiting!")
   }
}

avg_counts <- list()
for(sp in species) {
    avg_counts[[sp]] <- calcAvgCounts(counts_list[[sp]],
                                      metadata_list[[sp]])
}
# check tissue columns are matching in each species
c_tissues <- as.data.frame(sapply(avg_counts, function(x) {
            tstrsplit(colnames(x),"_")[[2]]
  }))
if( !all(apply(c_tissues,1,function(x) all(x == x[1])))) {
        stop("Error! tissues not matching")
}
```

The dimension of mean expression profiles
```{r}
sapply(avg_counts,dim)
```
Remove genes not expressed

```{r}
removeZeros <- function(df) {
    return(df[rowSums(df) > 0,])
}

avg_counts <- lapply(avg_counts, removeZeros)
sapply(avg_counts, dim)
# update counts_list
counts_list_sub <- list()
for(sp in names(avg_counts)){
  counts_list_sub[[sp]] = counts_list[[sp]][row.names(avg_counts[[sp]]), ,
                                                 drop = F]
}
```


# A-SBF

We will perform A-SBF in two ways.

1. Keeping initial estimate of $V$ same, while updating $U_i$ and $\Delta_i$ to
minimize the factorization error. By keeping the $V$ same, the initial $V$
estimated based inter-sample correlation is maintained.
2. Update $V$, $U_i$ and $\Delta_i$ to minimize the factorization error.

```{r}
cat("\n=======================================================")
cat("\nASBF with optimizing V = FALSE started\n")
cat(format(Sys.time(), "%a %b %d %X %Y"),"\n")
t1 <- proc.time()
sbf_noVupdate <- SBF(avg_counts, transform_matrix = TRUE, approximate = TRUE,
                     optimizeV = FALSE, tol = 1e-3)
t2 <- proc.time()
cat(format(Sys.time(), "%a %b %d %X %Y"),"\n")
cat("ASBF with optimizing V = FALSE finished\n")
cat("Time taken:\n")
t2 - t1
```


```{r}
cat("\n=======================================================")
cat("\nASBF with optimizing V=TRUE started\n")
cat(format(Sys.time(), "%a %b %d %X %Y"),"\n")
t1 <- proc.time()
sbf <- SBF(avg_counts, transform_matrix = TRUE, approximate = TRUE,
                     optimizeV = TRUE, tol = 1e-3)
t2 <- proc.time()
cat(format(Sys.time(), "%a %b %d %X %Y"),"\n")
cat("ASBF with optimizing V=TRUE finished\n")
cat("Time taken:\n")
t2 - t1
```
Note reduce the tolerance threshold (e.g 1e-10) to further minimize the
factorization error.

The final factorization error and number of updates taken:
```{r}
cat("\n", sprintf("%-25s:","Final error [No V update]"), sprintf("%16.2f",
                                                        sbf_noVupdate$error))
cat("\n", sprintf("%-25s:","Final error"), sprintf("%16.2f",sbf$error))
cat("\n", sprintf("%-25s:","# of update [No V update]"), sprintf("%16d",
                                                      sbf_noVupdate$error_pos))
cat("\n", sprintf("%-25s:","# of update"), sprintf("%16d",sbf$error_pos))
```



Calculate tissue specificity ($\Tau$) and scaled avg expression profile

```{r}
calc_tissue_specificity <- function(a) {
    a <- as.matrix(a)
    b <- a/rowMaxs(a)
    #b[is.na(b)]=0
    return(rowSums(1-b) / (ncol(b) - 1))
}
    
Tau <- lapply(avg_counts, function(x) { calc_tissue_specificity(x)} )
avg_counts_scaled <- lapply(avg_counts,function(x) { t(scale(t(x))) })

combine_expr <- list()
for(sp in names(avg_counts_scaled)) {
  x <- as.data.frame(avg_counts_scaled[[sp]])
  x[["Tau"]] <- Tau[[sp]]
  combine_expr[[sp]] <- x
}
```

