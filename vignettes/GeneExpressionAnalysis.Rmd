---
title: "Gene expression analysis using A-SBF"
author: "Amal Thomas"
output:
  pdf_document:
    toc: yes
    number_section: yes
  knitr:::html_vignette:
    toc: yes
  html_document:
    toc: yes
    df_print: paged
bibliography: references.bib
vignette: |
  %\VignetteIndexEntry{GeneExpressionAnalysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style>
body {
text-align: justify}
</style>

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

\newcommand{\diag}{\mathrm{diag}}
\newcommand{\tr}{\mathrm{tr}}
\newcommand{\E}{\mathrm{E}}

# Introduction

Consider a set of $k$ real matrices $D_i \in \mathbb{R}^{m_i \times n}$,
each with full column rank.
Each $D_i$ represents the mean expression of $n$ tissues (columns) in species
$i$ with $m_i$ genes (rows) annotated for that species.
The $p\mbox{-th}$ column of each $D_i$ matrix corresponds to the average
gene-expression profile of a functionally equivalent tissue representing
a similar phenotype across species.
The number of rows is different for each $D_i$ matrix, but they all have the
same number of columns.

In A-SBF, we estimate an orthonormal basis $V$ for the common expression
space based on the inter-tissue correlations within each species.
Let $X_i \in \mathbb{R}^{m_i \times n}$ be the standardized gene
expression matrix for species $i$. We can write
\[
X_i = C_iD_i{S_i}^{-1},
\]
where
\[
C_i = I_{m_i} - {m_i}^{-1} 1_{m_i} {1_{m_i}}^T
\]
is a centering matrix and $S_i = \diag(s_1,\ldots,s_n)$ is a diagonal
scaling matrix, where $s_j$ is the standard deviation of $j$-th column
of $D_i$. Within species $i$, the correlation between expression
profiles for the $n$ tissues is
\[
R_i = X_i^TX_i/m_i.
\]
Each $R_i$ matrix has a dimension of $n \times n$ independent of the 
number of genes annotated in the species.
Since the corresponding column of each $D_i$ matrix represents a similar 
phenotype, we can define an expected correlation matrix across the
species:

\[
E = \E(R) = \textstyle\frac{1}{k}\sum_{i=1}^{k} R_i.
\]

The shared right basis matrix $V$ represents the common expression space
and is determined from the eigenvalue decomposition of $E$,
where $E=V \Lambda V^T$.
The right basis matrix $V$ is identical in all the $k$ matrix factorizations,
and the different dimensions of $V$ represent the correlation relationship
between tissues independent of the fact to which species tissues belong.
Once the $V$ is estimated, the species-specific left basis matrix with
orthonormal columns $U_i$ (eigengenes) and the $\Delta_i$ that minimize
the factorization error are computed 

```{r setup}
# load SBF package
library(SBF)
```

Additional package required for the vignette
```{r}
pkgs <- c("data.table", "dplyr", "matrixStats", "RColorBrewer","ggplot2")
require_install <- pkgs[!(pkgs %in% row.names(installed.packages()))]
if (length(require_install))
  install.packages(require_install)
suppressPackageStartupMessages({
  library(data.table)
  library(dplyr)
  library(matrixStats)
  library(RColorBrewer)
  library(ggplot2)
})
```

Download the processed counts file from:
Read RNA-Seq counts data
```{r}
species <- c("Homo_sapiens", "Pan_troglodytes", "Macaca_mulatta",
             "Mus_musculus", "Rattus_norvegicus", "Bos_taurus",
             "Sus_scrofa","Gallus_gallus")
# common tissues present in all 8 species
tissues <-  c("brain", "heart", "kidney", "liver", "lung", "testis")
counts_path <- "/home/master/Dropbox/0.Analysis/0.paper/counts/"
```


```{r}
getSpeciesShortName <- function(species_list) {
    require(data.table)
    shortname <- c()
    for (sp in species_list) {
       if (!grepl("_", sp)) {
          cat("\nspecies:", sp,"\n")
          stop("Invalid species full name")
       }
       shortname <- c(shortname,
                       paste0(tolower(substr(tstrsplit(sp,"_")[[1]], 1, 1)),
                       tstrsplit(sp,"_")[[2]]))
    }
    return(shortname)
}
species_short <- sapply(species, getSpeciesShortName)
species_short
```

# Load gene expression profiles

```{r}
counts_list <- metadata_list <- list()
for (sp in species) {
  counts <- fread(paste0(counts_path, sp, "_logTPM.tsv"), sep = "\t",
                  header = T, data.table = FALSE, nThread = 4)
  row.names(counts) <- counts$V1
  counts$V1 <- NULL
  col_fields <- tstrsplit(colnames(counts),"_")
  metadata <- data.frame(
      project = col_fields[[1]],
      species = col_fields[[2]],
      tissue = col_fields[[3]],
      gsm = col_fields[[4]],
      name = colnames(counts),
      stringsAsFactors = F)
  metadata_sel <- metadata[metadata$tissue %in% tissues, , drop = F]
  counts_sel <- counts[ , colnames(counts) %in% metadata_sel$name, drop = F]
  metadata_sel$ref <- seq_len(nrow(metadata_sel))
  metadata_sel$key <- paste0(metadata_sel$species, "_", metadata_sel$tissue)

  counts_list[[sp]] <- counts_sel
  metadata_list[[sp]] <- metadata_sel

}
```

Dimensions and number of profiles for different species

```{r}
sapply(counts_list, dim)
```

Now, for each species, let us compute average expression profile for each tissue.

```{r}
#function to calcuate mean expression values for each tissue/group
calcAvgCounts <- function(counts, metadata, ndecimal = 4) {
   require(dplyr)
   counts.avg <- list()
   if ("key" %in% colnames(metadata)) {
     for (species.organ in sort(unique(metadata$key))) {
        no.of.libs <- length(colnames(counts)[grepl(species.organ,
                                                    colnames(counts))])
        if (no.of.libs > 1)
           counts.avg[[species.organ]] <- round(rowMeans(counts[, colnames(counts)[
                                   grepl(species.organ, colnames(counts))]],
                                   dim=1), ndecimal)
        else if (no.of.libs == 1)
           counts.avg[[species.organ]] <- round(counts[, colnames(counts)[grepl(
                              species.organ, colnames(counts))], drop = T], ndecimal)
     }
     avg.counts <- as.data.frame(counts.avg %>% bind_cols())
     row.names(avg.counts) <- row.names(counts)
     return(avg.counts)
   }else {
     stop("'key' column not found in the metadata!Exiting!")
   }
}

avg_counts <- list()
for(sp in species) {
    avg_counts[[sp]] <- calcAvgCounts(counts_list[[sp]],
                                      metadata_list[[sp]])
}
# check tissue columns are matching in each species
c_tissues <- as.data.frame(sapply(avg_counts, function(x) {
            tstrsplit(colnames(x),"_")[[2]]
  }))
if( !all(apply(c_tissues,1,function(x) all(x == x[1])))) {
        stop("Error! tissues not matching")
}
```

The dimension of mean expression profiles
```{r}
sapply(avg_counts,dim)
```
Remove genes not expressed

```{r}
removeZeros <- function(df) {
    return(df[rowSums(df) > 0,])
}

avg_counts <- lapply(avg_counts, removeZeros)
sapply(avg_counts, dim)
# update counts_list
counts_list_sub <- list()
for(sp in names(avg_counts)){
  counts_list_sub[[sp]] = counts_list[[sp]][row.names(avg_counts[[sp]]), ,
                                                 drop = F]
}
```


# A-SBF

We will perform A-SBF in two ways.

1. Keeping initial estimate of $V$ same, while updating $U_i$ and $\Delta_i$ to
minimize the factorization error. By keeping the $V$ same, the initial $V$
estimated based inter-sample correlation is maintained.
2. Update $V$, $U_i$ and $\Delta_i$ to minimize the factorization error.

```{r}
cat("\n=======================================================")
cat("\nASBF with optimizing V = FALSE started\n")
cat(format(Sys.time(), "%a %b %d %X %Y"),"\n")
t1 <- proc.time()
sbf_noVupdate <- SBF(avg_counts, transform_matrix = TRUE, approximate = TRUE,
                     optimizeV = FALSE, tol = 1e-3)
t2 <- proc.time()
cat(format(Sys.time(), "%a %b %d %X %Y"),"\n")
cat("ASBF with optimizing V = FALSE finished\n")
cat("Time taken:\n")
t2 - t1
```


```{r}
cat("\n=======================================================")
cat("\nASBF with optimizing V=TRUE started\n")
cat(format(Sys.time(), "%a %b %d %X %Y"),"\n")
t1 <- proc.time()
sbf <- SBF(avg_counts, transform_matrix = TRUE, approximate = TRUE,
                     optimizeV = TRUE, tol = 1e-3)
t2 <- proc.time()
cat(format(Sys.time(), "%a %b %d %X %Y"),"\n")
cat("ASBF with optimizing V=TRUE finished\n")
cat("Time taken:\n")
t2 - t1
```
Note: reduce the tolerance threshold (e.g 1e-10) to further minimize the
factorization error.

The final factorization error and number of updates taken:
```{r}
cat("\n", sprintf("%-25s:","Final error [No V update]"), sprintf("%16.2f",
                                                        sbf_noVupdate$error))
cat("\n", sprintf("%-25s:","Final error"), sprintf("%16.2f",sbf$error))
cat("\n", sprintf("%-25s:","# of update [No V update]"), sprintf("%16d",
                                                      sbf_noVupdate$error_pos))
cat("\n", sprintf("%-25s:","# of update"), sprintf("%16d",sbf$error_pos))
```
Percentage of information ($p_{ij}$) represented by a common space dimension is
defined as
$\textstyle{p_{ij} = \delta_{ij}^2 / \sum_{j=1}^6 \delta_{ij}^2 \times 100}$,
$\mbox{ where } \textstyle{\Delta_i = \diag(\delta_{i1},\ldots, \delta_{i6})}$

```{r}
percentInfo_noVupdate <- lapply(sbf_noVupdate$d, function(x){round(x^2/sum(x^2) * 100,2)})
cat("\nPercentage for each delta [No V update]:")
for (i in names(sbf_noVupdate$d)) {
  cat("\n", sprintf("%-25s:",i),sprintf("%8.2f", percentInfo_noVupdate[[i]]))
}
cat("\n-------------------------------------------------------------------------")


percentInfo <- lapply(sbf$d, function(x) { round(x^2/sum(x^2) * 100, 2) })
cat("\nPercentage for each delta:")
for (i in names(sbf$d)) {
  cat("\n", sprintf("%-25s:",i), sprintf("%8.2f", percentInfo[[i]]))
}
```
The percentage of information represented by different dimensions 
looks very similar for both the cases.

# Project libraries to common space

Let us first compute $\Delta^{-1}$

```{r}
d_inv_NoVupdate <- list()
for (sp in names(avg_counts)) {                                             
        if(length(sbf_noVupdate$d[[sp]]) == 1) {       
                d_inv_NoVupdate[[sp]] <- as.matrix(diag(as.matrix(1/sbf_noVupdate$d[[sp]])))
        } else {                                                         
                d_inv_NoVupdate[[sp]] <- as.matrix(diag(1/sbf_noVupdate$d[[sp]]))           
        }                                                              
}
d_inv <- list()
for (sp in names(avg_counts)) {                                             
        if(length(sbf$d[[sp]]) == 1) {       
                d_inv[[sp]] <- as.matrix(diag(as.matrix(1/sbf$d[[sp]])))
        } else {                                                         
                d_inv[[sp]] <- as.matrix(diag(1/sbf$d[[sp]]))           
        }                                                              
}
```


```{r}
# function to return scientific name
species_scientific <- function(x) {
  parts <- tstrsplit(x,"_")
  return(paste0(substr(x, 1, 1), ".", parts[[2]]))
}
```

Project individual profiles and average counts to common space by computing
$D_i^T U_i \Delta^{-1}$

```{r}
# project using no V update estimates
avgcounts_projected_noVupdate  <- counts_projected_noVupdate <- list()
n_noVupdate <- n1_noVupdate <- c()
for (sp in names(avg_counts)) {
  avgcounts_projected_noVupdate[[sp]] <- as.matrix(t(avg_counts[[sp]])) %*%
    as.matrix(sbf_noVupdate$u[[sp]]) %*% d_inv_NoVupdate[[sp]]
  n_noVupdate <- c(n_noVupdate, row.names(avgcounts_projected_noVupdate[[sp]]))
  
  counts_projected_noVupdate[[sp]] <- as.matrix(t(counts_list_sub[[sp]])) %*%
    as.matrix(sbf_noVupdate$u[[sp]]) %*% d_inv_NoVupdate[[sp]]
  n1_noVupdate <- c(n1_noVupdate, row.names(counts_projected_noVupdate[[sp]]))
}

# combine projected profiles
df_proj_avg_noVupdate <- as.data.frame(do.call(rbind, avgcounts_projected_noVupdate))
rownames(df_proj_avg_noVupdate) <- n_noVupdate
colnames(df_proj_avg_noVupdate) <- paste0("Dim",1:ncol(df_proj_avg_noVupdate))
meta <- tstrsplit(row.names(df_proj_avg_noVupdate),"_")
df_proj_avg_noVupdate$tissue <- factor(meta[[2]])
df_proj_avg_noVupdate$species <- factor(meta[[1]])
df_proj_avg_noVupdate <- df_proj_avg_noVupdate %>% mutate(species = factor(species,
                            levels = species_short))


df_proj_noVupdate <- as.data.frame(do.call(rbind, counts_projected_noVupdate))
rownames(df_proj_noVupdate) <- n1_noVupdate
colnames(df_proj_noVupdate) <- paste0("Dim", 1:ncol(df_proj_noVupdate))
meta1 <- tstrsplit(row.names(df_proj_noVupdate), "_")
df_proj_noVupdate$tissue <- factor(meta1[[3]])
df_proj_noVupdate$species <- factor(meta1[[2]])
df_proj_noVupdate <- df_proj_noVupdate %>% mutate(species = factor(species,
                            levels = species_short))

# project using V update estimates
avgcounts_projected  <- counts_projected <- list()
n <- n1 <- c()
for (sp in names(avg_counts)) {
  avgcounts_projected[[sp]] <- as.matrix(t(avg_counts[[sp]])) %*%
    as.matrix(sbf$u[[sp]]) %*% d_inv[[sp]]
  n <- c(n, row.names(avgcounts_projected[[sp]]))
  
  counts_projected[[sp]] <- as.matrix(t(counts_list_sub[[sp]])) %*%
    as.matrix(sbf$u[[sp]]) %*% d_inv[[sp]]
  n1 <- c(n1, row.names(counts_projected[[sp]]))
}

# combine projected profiles
df_proj_avg <- as.data.frame(do.call(rbind, avgcounts_projected))
rownames(df_proj_avg) <- n
colnames(df_proj_avg) <- paste0("Dim",1:ncol(df_proj_avg))
meta <- tstrsplit(row.names(df_proj_avg),"_")
df_proj_avg$tissue <- factor(meta[[2]])
df_proj_avg$species <- factor(meta[[1]])
df_proj_avg <- df_proj_avg %>% mutate(species = factor(species,
                            levels = species_short))


df_proj <- as.data.frame(do.call(rbind, counts_projected))
rownames(df_proj) <- n1
colnames(df_proj) <- paste0("Dim", 1:ncol(df_proj))
meta1 <- tstrsplit(row.names(df_proj), "_")
df_proj$tissue <- factor(meta1[[3]])
df_proj$species <- factor(meta1[[2]])
df_proj <- df_proj %>% mutate(species = factor(species,
                            levels = species_short))

```


# 2D plots in common space

```{r}
customTheme <- function(base_size=10, base_family="helvetica"){
   require(grid)
   require(ggthemes)
   (theme_foundation(base_size=base_size)
   + theme(plot.title = element_text(face = "bold",
                                   size = rel(1.2), hjust = 0.5),
         text = element_text(),
         panel.background = element_rect(colour = NA),
         plot.background = element_rect(colour = NA),
         panel.border = element_rect(colour = NA),
         axis.title = element_text(size = rel(1)),
         axis.title.y = element_text(angle=90,vjust =2),
         axis.title.x = element_text(vjust = -0.2),
         axis.text = element_text(),
         axis.line = element_line(colour="black"),
         axis.ticks = element_line(),
         panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         legend.key = element_rect(colour = NA),
         legend.position = "top",
         legend.direction = "horizontal",
         legend.key.size= unit(0.2, "cm"),
         legend.spacing = unit(0, "cm"),
         legend.title = element_text(face="italic"),
         plot.margin=unit(c(10,5,5,5),"mm"),
         strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
         strip.text = element_text(face="bold")))
}
```


```{r}
sel_colors <- brewer.pal(8,"Dark2")[1:length(unique(df_proj$tissue))]
i <- 1
j <- 2
ggplot(df_proj_noVupdate, aes(x = df_proj_noVupdate[,i],
                              y = df_proj_noVupdate[,j], col = tissue,
                              shape = species, fill = tissue)) +  
  xlab(paste("A-SBF Dim", i)) + ylab(paste("A-SBF Dim", j)) +
  geom_point(size=1.5) + scale_color_manual(values = sel_colors) + 
  scale_shape_manual(values = c(21:25,3:7)) +
  scale_fill_manual(values = sel_colors) + 
  customTheme() + 
  theme(legend.title = element_blank())
```

Calculate tissue specificity ($\tau$) and scaled avg expression profile

```{r}
calc_tissue_specificity <- function(a) {
    a <- as.matrix(a)
    b <- a / rowMaxs(a)
    #b[is.na(b)]=0
    return(rowSums(1-b) / (ncol(b) - 1))
}
    
Tau <- lapply(avg_counts, function(x) { calc_tissue_specificity(x)} )
avg_counts_scaled <- lapply(avg_counts,function(x) { t(scale(t(x))) })

combine_expr <- list()
for(sp in names(avg_counts_scaled)) {
  x <- as.data.frame(avg_counts_scaled[[sp]])
  x[["Tau"]] <- Tau[[sp]]
  combine_expr[[sp]] <- x
}
```

